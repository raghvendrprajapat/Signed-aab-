name: Build Web to Signed Android

on:
  workflow_dispatch:
    inputs:
      WEB_APP_URL:
        description: "URL of the web application to bundle (git, zip, or live site)"
        required: true
      httpsOnly:
        description: "Enforce HTTPS for all provided URLs"
        type: boolean
        default: true
      targetSdk:
        description: "Android target SDK version"
        type: number
        default: 35
      iconPngUrl:
        description: "Optional: HTTPS URL to a PNG for the app icon"
        required: false
      splashPngUrl:
        description: "Optional: HTTPS URL to a PNG for the splash screen"
        required: false
      buildType:
        description: "Android build type"
        type: choice
        default: 'release'
        options:
          - 'release'
          - 'debug'
      versionCode:
        description: "Android version code (integer)"
        type: number
        default: 1
      versionName:
        description: "Android version name"
        type: string
        default: "1.0.0"

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 50

    env:
      WEB_APP_URL: ${{ github.event.inputs.WEB_APP_URL }}
      VERSION_CODE: ${{ github.event.inputs.versionCode }}
      VERSION_NAME: ${{ github.event.inputs.versionName }}
      TARGET_SDK: ${{ github.event.inputs.targetSdk }}
      MIN_SDK: "22"

      KEYSTORE_BASE64:   ${{ secrets.keystoreFileBase64 }}
      KEYSTORE_PASSWORD: ${{ secrets.keystorePassword }}
      KEY_ALIAS:         ${{ secrets.keystoreAlias }}
      KEY_PASSWORD:      ${{ secrets.keystorePassword }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Validate Inputs
        shell: bash
        run: |
          set -euo pipefail
          # ensure WEB_APP_URL provided
          if [ -z "${{ inputs.WEB_APP_URL }}" ]; then
            echo "::error::WEB_APP_URL is required"
            exit 11
          fi

          # enforce httpsOnly
          if [ "${{ inputs.httpsOnly }}" = "true" ]; then
            if [[ "${{ inputs.WEB_APP_URL }}" != https://* ]]; then
              echo "::error::Insecure URL detected. Only HTTPS URLs are allowed for WEB_APP_URL."
              exit 11
            fi
            # same for optional icon/splash
            if [ -n "${{ inputs.iconPngUrl }}" ] && [[ "${{ inputs.iconPngUrl }}" != https://* ]]; then
              echo "::error::iconPngUrl must be HTTPS."
              exit 11
            fi
            if [ -n "${{ inputs.splashPngUrl }}" ] && [[ "${{ inputs.splashPngUrl }}" != https://* ]]; then
              echo "::error::splashPngUrl must be HTTPS."
              exit 11
            fi
          fi

          # Check for keystore secrets
          for var in KEYSTORE_BASE64 KEYSTORE_PASSWORD KEY_ALIAS; do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing required secret: $var"
              exit 1
            fi
          done

      - name: Fetch, Build, and Prepare Web App
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Fetching Web App"
          mkdir -p web_src
          cd web_src

          if [[ "$WEB_APP_URL" == *.git ]] || [[ "$WEB_APP_URL" == *github.com* ]]; then
            echo "Source appears to be a Git repository. Cloning..."
            git clone --depth=1 "$WEB_APP_URL" .
          elif [[ "$WEB_APP_URL" == *.zip ]]; then
            echo "Source appears to be a ZIP file. Downloading and extracting..."
            curl -fL "$WEB_APP_URL" -o web.zip
            unzip web.zip
          else
            echo "Source appears to be a live website. Mirroring with wget..."
            wget --mirror --convert-links --adjust-extension --no-parent --no-verbose "$WEB_APP_URL"
            # Wget creates a directory based on the domain, find it and move its contents up
            WGET_DIR=$(find . -maxdepth 1 -type d -name "*.*" -print | head -n 1)
            if [ -d "$WGET_DIR" ]; then
              mv $WGET_DIR/* .
              rmdir "$WGET_DIR"
            fi
          fi
          echo "::endgroup::"

          echo "::group::Building Web App (if necessary)"
          PKG_JSON=$(find . -maxdepth 2 -name package.json -print -quit)
          if [ -f "$PKG_JSON" ]; then
            echo "package.json found at $PKG_JSON. Running build..."
            cd $(dirname "$PKG_JSON")
            if [ -f package-lock.json ]; then npm ci; else npm install; fi
            if npm run | grep -q " build"; then
              npm run build
            else
              echo "No 'build' script found in package.json, assuming static assets."
            fi
            cd -
          else
            echo "No package.json found. Assuming static assets."
          fi
          echo "::endgroup::"

          echo "::group::Locating Web App Build Directory"
          BUILD_DIR=""
          for d in dist build public; do
            DIR_PATH=$(find . -maxdepth 3 -type d -name "$d" -print -quit)
            if [ -d "$DIR_PATH" ]; then
              BUILD_DIR="$DIR_PATH"
              break
            fi
          done

          if [ -z "$BUILD_DIR" ]; then
            # If no standard build directory, find the first directory containing index.html
            INDEX_HTML=$(find . -maxdepth 3 -name index.html -print -quit)
            if [ -f "$INDEX_HTML" ]; then
              BUILD_DIR=$(dirname "$INDEX_HTML")
            else
              echo "❌ Critical: Could not find a web build directory (dist, build, public) or an index.html file."
              exit 1
            fi
          fi

          echo "Web build directory identified: $BUILD_DIR"
          # Use a relative path for the environment variable
          FINAL_BUILD_DIR=$(realpath --relative-to=$PWD/.. "$BUILD_DIR")
          echo "WEB_BUILD_DIR=$FINAL_BUILD_DIR" >> $GITHUB_ENV
          echo "::endgroup::"

          npm install -D @capacitor/core @capacitor/cli @capacitor/android

      - name: Restore keystore
        shell: bash
        run: |
          set -euo pipefail
          echo "$KEYSTORE_BASE64" | base64 -d > android.keystore
          ls -l android.keystore

      - name: Apply Branding Assets
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y imagemagick
          # Optional Icon Processing
          if [ -n "${{ inputs.iconPngUrl }}" ]; then
            echo "::group::Applying custom icon"
            curl -fL "${{ inputs.iconPngUrl }}" -o icon.png
            # Create adaptive icon backgrounds and foregrounds
            convert icon.png -gravity center -extent 108x108 android/app/src/main/res/mipmap-mdpi/ic_launcher.png
            convert icon.png -gravity center -extent 162x162 android/app/src/main/res/mipmap-hdpi/ic_launcher.png
            convert icon.png -gravity center -extent 216x216 android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
            convert icon.png -gravity center -extent 324x324 android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
            convert icon.png -gravity center -extent 432x432 android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
            # Create legacy round icons
            convert icon.png -resize 48x48 android/app/src/main/res/mipmap-mdpi/ic_launcher_round.png
            convert icon.png -resize 72x72 android/app/src/main/res/mipmap-hdpi/ic_launcher_round.png
            convert icon.png -resize 96x96 android/app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
            convert icon.png -resize 144x144 android/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
            convert icon.png -resize 192x192 android/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
            echo "::endgroup::"
          fi
          # Optional Splash Screen Processing
          if [ -n "${{ inputs.splashPngUrl }}" ]; then
            echo "::group::Applying custom splash screen"
            curl -fL "${{ inputs.splashPngUrl }}" -o splash.png
            # Copy to all drawable densities
            for dir in drawable-land-mdpi drawable-land-hdpi drawable-land-xhdpi drawable-land-xxhdpi drawable-land-xxxhdpi drawable-port-mdpi drawable-port-hdpi drawable-port-xhdpi drawable-port-xxhdpi drawable-port-xxxhdpi; do
              mkdir -p android/app/src/main/res/$dir
              cp splash.png android/app/src/main/res/$dir/splash.png
            done
            echo "::endgroup::"
          fi

      - name: Copy Web Assets to Android Project
        shell: bash
        run: |
          set -euo pipefail
          echo "Copying web assets from $WEB_BUILD_DIR to android/app/src/main/assets/public..."
          rm -rf android/app/src/main/assets/public
          mkdir -p android/app/src/main/assets/public
          cp -R "$WEB_BUILD_DIR"/* android/app/src/main/assets/public/

          echo "Verifying copied assets..."
          ls -la android/app/src/main/assets/public | sed -n '1,200p'
          if [ ! -f "android/app/src/main/assets/public/index.html" ]; then
            echo "❌ Critical: index.html not found in android/app/src/main/assets/public after copy."
            exit 11
          fi
          echo "✅ Web assets copied and verified successfully."

      - name: Configure Capacitor for Offline Bundling
        shell: bash
        run: |
          set -euo pipefail
          # Check for existing capacitor.config.json and extract values
          if [ -f "web_src/capacitor.config.json" ]; then
            echo "Found existing capacitor.config.json. Extracting values..."
            APP_ID=$(jq -r '.appId' web_src/capacitor.config.json)
            APP_NAME=$(jq -r '.appName' web_src/capacitor.config.json)
          else
            echo "No capacitor.config.json found. Using default values."
            APP_ID="com.example.app"
            APP_NAME="My App"
          fi

          # Create a new capacitor.config.json for a fully offline-bundled app.
          # "bundledWebRuntime" is true and the "server" key is omitted.
          printf '{\n' > capacitor.config.json
          printf '  "appId": "%s",\n' "$APP_ID" >> capacitor.config.json
          printf '  "appName": "%s",\n' "$APP_NAME" >> capacitor.config.json
          printf '  "webDir": "android/app/src/main/assets/public",\n' >> capacitor.config.json
          printf '  "bundledWebRuntime": true\n' >> capacitor.config.json
          printf '}\n' >> capacitor.config.json

          echo "Capacitor config generated for offline bundling:"
          cat capacitor.config.json

          # Add Android platform and sync all web assets
          npx cap add android
          npx cap sync android

      - name: Patch Gradle
        shell: bash
        working-directory: android
        run: |
          set -euo pipefail
          cp ../android.keystore app/release.keystore
          if [ -f app/build.gradle ]; then FILE="app/build.gradle"; else FILE="app/build.gradle.kts"; fi
          # Use more robust sed commands that handle different spacing and quoting
          sed -i -E "s/versionCode\s+[0-9]+/versionCode $VERSION_CODE/" "$FILE"
          sed -i -E "s/versionName\s+\"[^\"]+\"/versionName \"$VERSION_NAME\"/" "$FILE"
          sed -i -E "s/targetSdk(Version)?\s+[0-9]+/targetSdk $TARGET_SDK/" "$FILE"
          sed -i -E "s/compileSdk(Version)?\s+[0-9]+/compileSdk $TARGET_SDK/" "$FILE"
          # Also update minSdkVersion for consistency
          sed -i -E "s/minSdk(Version)?\s+[0-9]+/minSdk $MIN_SDK/" "$FILE"
          if ! grep -q "signingConfigs" "$FILE"; then
            {
              echo ""
              echo "android {"
              echo "    signingConfigs {"
              echo "        release {"
              echo "            storeFile file(\"release.keystore\")"
              echo "            storePassword System.getenv(\"KEYSTORE_PASSWORD\")"
              echo "            keyAlias      System.getenv(\"KEY_ALIAS\")"
              echo "            keyPassword   System.getenv(\"KEY_PASSWORD\")"
              echo "        }"
              echo "    }"
              echo "    buildTypes {"
              echo "        release {"
              echo "            signingConfig signingConfigs.release"
              echo "            minifyEnabled false"
              echo "            shrinkResources false"
              echo "            debuggable false"
              echo "        }"
              echo "    }"
              echo "}"
            } >> "$FILE"
          fi

      - name: Build app
        shell: bash
        working-directory: android
        run: |
          set -euo pipefail
          BUILD_TYPE="${{ github.event.inputs.buildType }}"
          BUILD_TYPE_CAPITALIZED="$(tr '[:lower:]' '[:upper:]' <<< ${BUILD_TYPE:0:1})${BUILD_TYPE:1}"

          ./gradlew clean --no-daemon
          ./gradlew :app:bundle${BUILD_TYPE_CAPITALIZED} :app:assemble${BUILD_TYPE_CAPITALIZED} --no-daemon

          mkdir -p ../out_aab ../out_apk
          cp app/build/outputs/bundle/${BUILD_TYPE}/*.aab ../out_aab/
          cp app/build/outputs/apk/${BUILD_TYPE}/*.apk ../out_apk/

          echo "=== AAB files ==="; ls -l ../out_aab
          echo "=== APK files ==="; ls -l ../out_apk

      - name: Verify build artifacts
        shell: bash
        run: |
          set -euo pipefail
          if ! ls out_aab/*.aab 1> /dev/null 2>&1; then
            echo "❌ Build failed: No AAB files found in out_aab directory."
            exit 1
          fi
          if ! ls out_apk/*.apk 1> /dev/null 2>&1; then
            echo "❌ Build failed: No APK files found in out_apk directory."
            exit 1
          fi
          echo "✅ Build artifacts found."

      - name: Upload signed AAB
        uses: actions/upload-artifact@v4
        with:
          name: signed-aab
          path: out_aab/*.aab

      - name: Upload signed APK
        uses: actions/upload-artifact@v4
        with:
          name: signed-apk
          path: out_apk/*.apk
